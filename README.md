# Gifter v1
<p> Project Name: Gifter (cpt202 Software Engineering Group Project) </p>
Project Team: 

## Report on Software Development Life Cycle (SDLC)

| Project Details | Description | 
| :---         |     :---:      |       
| **Project Name**   | Gifter (A CPT202 Software Engineering Group Project)    | 
| **Project Team**     | Yuezhen Qin, CLY, JD, ZWH, CHJ, LKW, XTY       | 

 ## Timeline
![CPT202-Assignment2-GroupReport-Group33](https://github.com/YuezhenQin/Gifter/assets/37969376/edf8baee-c16f-40ce-bae1-4e7401d7a960)
Figure 1. 10 Weeks (3.15(Week4)-5.21(Week14))


### Requirements gathering and analysis
Accurate, complete, and measurable user requirements are the foundation for any successful SDLC project—to ensure that the software meets user expectations and to avoid costly rework and project delays. The IT business analyst:

Gathers requirements by conducting interviews, holding workshops or focus groups, preparing surveys or questionnaires, and observing how stakeholders work.
Evaluates the requirements as they relate to system feasibility, and software design and testing.
Models the requirements and records them in a document, such as a user story, software requirements specification, use case document, or process specification.
### System design
Effective system design properly accounts for all documented requirements. In this phase, software architects use tools to visualize information about the application’s behavior and structure, including:

The unified modeling language (UML) to illustrate the software’s architectural blueprints in a diagram.
Data flow diagrams to visualize system requirements.
Decision trees and decision tables to help explain complex relationships.
Simulations to predict how the software will perform.
To support the distinct layers within a software application, software architects use a design principle called separation of concerns. A software program that’s designed to align with the separation of concerns principle is called a modular program.

Modular software design separates program functionality into interchangeable, independent modules, so that each module contains everything it needs to execute one aspect of the software’s functionality. This approach makes it easier to understand, test, maintain, reuse, scale, and refactor code.

### Coding
In the coding phase, developers translate the system design specifications into actual code. It’s critical that developers follow best practices for writing clean, maintainable, and efficient code, including:

Writing code that’s easy to understand and read.
Using comments to explain what the code does.
Using version control to track any changes to the codebase.
Refactoring the code if needed.
Conducting a code review when coding is completed to get a second opinion on the code.
Providing code documentation that explains how the code works.
### Testing
Before it’s released to production, the software is thoroughly tested for defects and errors.

The software test plan provides critical information about the testing process, including the strategy, objectives, required resources, deliverables, and criteria for exit or suspension.
Test case design establishes the criteria for determining if the software is working correctly or not.
Test execution is the process of running the test to identify any bugs or software defects.
Developers and quality assurance teams use automated testing tools to quickly test software, prepare defect reports, and compare testing results with expected outcomes. Automated testing saves time and money, provides immediate feedback, and helps improve software quality. Automated testing can be used for:

Unit testing. Developers test the individual software modules to validate that each one is working correctly.
Integration testing. Developers test how the different modules interact with each other to verify that they work together correctly.
System testing. Developers test the software to verify that it meets the requirements and works correctly in the production environment.
User acceptance testing. Stakeholders and users test the software to verify and accept it before it’s deployed to production.
### Deployment
There are three main phases to deploying software in a production environment:

The development team commits the code to a software repository.
The deployment automation tool triggers a series of tests.
The software is deployed to production and made available to users.
Effective software installation requires a consistent deployment mechanism and a simple installation structure with minimal file distribution. The team must also make sure that the correct configuration file is copied to the production environment and that the correct network protocols are in place. Before migrating data to the new system, the team also needs to audit the source data and resolve any issues.

Release management makes software deployment smooth and stable. This process is used to plan, design, schedule, test, and deploy the release. Versioning helps ensure the integrity of the production environment when upgrades are deployed.

### Maintenance and support
After the software is deployed, the software maintenance lifecycle begins. Software requires ongoing maintenance to ensure that it operates at peak performance. Developers periodically issue software patches to fix bugs in the software and resolve any security issues.

Maintenance activities also include performance monitoring of both the software’s technical performance and how users perceive its performance. Providing training and documentation to users, along with addressing user issues and upgrading their systems to make sure they’re compatible with the new software, are also key components of the software maintenance lifecycle.
